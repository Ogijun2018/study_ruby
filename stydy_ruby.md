# 1日目
Bundlerとは
　RubyGemsを管理するツール

RubyGemsとは
　Rubyで書かれたサードパーティ製のライブラリ
　（ユーザ認証機能、管理画面の機能など）

Rubyの主な特徴
- オブジェクト指向
- シンプルな文法
- 強力な標準ライブラリ
- 国際標準

RubyとRuby on Railsの違い

- Ruby
 プログラミング言語
- Ruby on Rails
 - Rubyで書かれたWebアプリケーションフレームワーク
 - Web開発における共通した作業を伴う労力を軽減
 - Webアプリケーションを少ないコード量で開発

puts...標準出力
nilと表示されるのは評価結果
putsは必ずnilを返す

定数は慣習上大文字で書く

リテラルとは
- 数値の123や文字列の'Hello World!"など、Rubyのプログラムの中に直接記述できるあたいのことをリテラルと言う。


Numeric => 数値クラス
 Integer => 整数クラス
 Float => 小数点クラス

### 変数を浮動小数点に変換するメソッド…
 x = 1
 x.to_f => 1.0

### クラスを判定するメソッド…
- .class
### 使えるメソッドを表示…
- .methods

## 文字列
- 特殊文字を使う場合はダブルクオート（"）を使う
- #{hensuu}を使うと変数名を表示できる
- シングルクオートはただの文字列として出てくる
### 文字列を全て大文字にするメソッド…
- s.upcase => 自身（s）は変更されない
- s.upcase! => 自身（s）が変更される

## 数値と文字列は暗黙的に変換されない
1 + '1' => error
1 + '1'.to_i => 文字列が整数に変換
1 + '1.1'.to_f => 文字列が小数点に変換
'Number is ' + number.to_s => 数値が文字列に変換

## インクリメント、デクリメント
++や--はない
n += 1とか n -= 1にする(pythonと同じ)

## and or not
Rubyは&&とか||も使えるけど、and や or や notも使える=> 優先順位は&&, ||の方が高い

!t1 || t1 => true
not t1 || t1 => false
t1 || t2 && f1 => true
t1 or t2 and f1 => false

## 条件文
else ifにする場合はRubyは "elsif" にする
条件文の終わりにはendを書く
unless…ifと反対の動作をする(elsifのようなものが存在しない)
case…条件分岐
when 値 で繋げていく
else どの値とも一致しない場合
end

## メソッド
def メソッド名（引数1, 引数2, ...)
  x + y
end

puts add(10,1) => 11
returnはいらない　最後に評価されたものが返り値になる

メソッド名は小文字の英数を使用する
単語同士はスネークケース

## 出力
puts => 中身の後に改行し、戻り値をターミナルに表示する
print => 改行しない
p => 戻り値が引数のオブジェクトになる（デバッグ用）
pp => 適切なインデントと改行で表示される（デバッグ用）

## 配列
a = [1, 2, 3, 'aa', [1,2,3]]
数値や文字列, 配列が混在していても入れることはできる
配列が空か判定するメソッド => .empty?
配列に要素があるか判定 => .include?('aa')
配列を反転 => .reverse（非破壊） .reverse!（破壊）
シャッフル => .shuffle（非破壊） .shuffle!（破壊）
配列を作成する => .to_a
例: (0..25).to_a => 0から25までの数字の配列を作成する

配列に要素を追加
 << 要素 もしくは .push(要素)
配列から要素を取り出す
  - 前から取り出す => .shift
  - 後ろからより出す => .pop

配列から重複をなくす => .uniq（非破壊） .uniq!（破壊）
配列の要素を結合 => .join s.join(' ')
配列の並び替え => .sort（非破壊） .sort!（破壊）
要素の個数を取得 => .size

## ハッシュ
JSでいう連想配列と同じ
変数名 = {'要素名' => '要素', ...}
puts 変数名[要素名]で出力できる（入力も）

シンボル…ソースコード上では文字列のように見えるが、内部では整数として扱われるもの
シンボルを使ったキーの方が、文字列をキーに使う場合に比べて、Hashのアクセスは早いとされる

シンボルを使ったハッシュはこんな感じ
sato = {name: 'Sato', birthplace: 'Tokyo'}
puts sato[:name] => Sato
ハッシュの持っているキーを確認 => .keys
ハッシュの持っている値を確認 => .values

## 繰り返し処理
### each for
配列やハッシュ.each do |変数|
 #繰り返し実行したい処理
end

配列やハッシュ.each { |変数|
 #繰り返し実行したい処理
}

配列やハッシュ.each { |変数| #繰り返し実行したい処理 }

どの方法でも書ける

for 変数 in 配列やハッシュ do
 #繰り返し実行したい処理
end

forは原則使わない eachを使う

### each（ハッシュを使った場合）
scores = {luke: 100, jack: 90, robert: 70}
scores.each do |key, value|
    puts "#{key}, #{value}
end

=> luke, 100
   jack, 90
   robert, 70
と表示される

### times
配列を使わないで指定回数を繰り返したい場合に使う
5.times do |i|
    puts "#{i}: Hello"
end

=> 0: Hello
   1: Hello
   ...
と表示される

### while
while 条件式 do
 ...
end

### upto downto
数値を1ずつ増やしながら、減らしながら処理をしたいときに使う
10.upto(14) { |n| puts n } => 10から14まで
14.downto(10) { |n| puts n } => 14から10まで

### step
nからmまでxずつ値を増やしながら処理をするときに使う
1.step(10, 2) => 1,3,5,7,9
10.step(1, -2) => 10,8,6,4,2

### loop, break, 
loop...強制的にループしたい場合に使う
break...ループから抜け出すときに使う
next...breakと同じように使って、現在の処理をスキップする（continueと同じ感じ）

## オリジナルのクラスを作成する
initializeという関数はnewが使われた時に最初に呼ばれる特別な関数
変数の前に@をつけるとインスタンス変数となり、クラスの中で使える変数になる

## アクセサメソッド
- インスタンス変数の値を読み書きするメソッドのこと
attr_accessor :name とすることで、
car = Car.new("Kitt") <= ここでKittという名前で初期化される
car.name = "Change" <= ここでChangeという名前が再定義される
読み取りと書き込みが自前でメソッドを書かなくても実装できるので便利

## クラス変数
- クラス自体に値を保持することができる変数
アットマーク二つ(@@)で定義

## クラスメソッド
- クラスから直接呼び出すことができるメソッド
def self.(メソッド名)とすることでメソッドが使える。
- クラスの定数を作成するときは変数を大文字にする
クラス中の定数をクラスの外から呼び出すときはコロン二つ（::）

## クラスの継承
子クラスを作成するときは
def 子クラス < 親クラス で定義。子クラスは親クラスのメソッドをつかえて、子クラスは親クラスと同じクラス名でオーバーライドすることができる。

親クラスはsuperclassメソッドで確認できる。

## モジュール
- クラスのようにメソッドや定数をまとめられるもの
- インスタンスを作ることができない
- 継承ができない
- 関連するメソッドや定数などをまとめてグループ化したいだけのときに、手軽に使えて便利

module モジュール名
end

モジュールはインスタンスを作れないので、中のクラスには全部selfがつく

## 例外と例外処理
- 例外、つまり予期しないエラーが発生した時に、それをキャッチして、ユーザにメッセージを表示するなど、なんらかの処理を行うこと。

- beginで処理を始める
- rescue: 例外が起こった時に使われる関数
- ensure: 例外が発生してもしなくても行う処理
- beginの中で複数の処理があるときは例外が起こるまでは処理がなされ、例外が発生してから下は処理されない

## メソッドの公開範囲
- public 誰からも見える
- protected あまり使われない
- private 自分からしか見えない